# Краткое описание паттернов.
---

## Немного о паттернах.

Что представляют собой паттерны проектирования? Паттерн представляет определенный способ построения программного кода для решения часто встречающихся проблем проектирования. В данном случае предполагается, что есть некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.

## Виды паттернов.
* __Порождающие паттерны__ — это паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов.
*  __Структурные паттерны__ - группа паттернов рассматривает, как классы и объекты образуют более крупные структуры - более сложные по характеру классы и объекты
* __Поведенчиские паттерны__ - они определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение

## Как выбрать нужный паттерн?

Прежде всего при решении какой-нибудь проблемы надо выделить все используемые сущности и связи между ними и абстрагировать их от конкретной ситуации. Затем надо посмотреть, вписывается ли абстрактная форма решения задачи в определенный паттерн. Например, суть решаемой задачи может состоять в создании новых объектов. В этом случае, возможно, стоит посмотреть на порождающие паттерны. Причем лучше не сразу взять какой-то определенный паттерн - первый, который показался нужным, а посмотреть на несколько родственных паттернов из одной группы, которые решают одну и ту же задачу.

---
## поведенческие (behavioral).

+ ### [Хранитель (memento).](https://github.com/georgedem975/patterns/tree/master/Memento)
    __Хранитель__ (Memento), также известный как Снимок – поведенческий паттерн проектирования. Он позволяет определять, сохранять, а также восстанавливать предыдущие состояния объектов без нарушения принципа инкапсуляции. Самый простой и наглядный пример использования этого паттерна – некий текстовый редактор, который позволяет изменять форматирование текста и других элементов. Но при этом пользователь может эти изменения отменить.

    * ___Когда использовать Memento?___
        + Когда нужно сохранить состояние объекта для возможного последующего восстановления
        + Когда сохранение состояния должно проходить без нарушения принципа инкапсуляции

+ ### [Цепочка обязанностей (chain of responsibility).](https://github.com/georgedem975/patterns/tree/master/Chain%20of%20responsibility)
    __Цепочка Обязанностей__ (Chain of responsibility) - поведенческий шаблон проектирования, который позволяет избежать жесткой привязки отправителя запроса к получателю. Все возможные обработчики запроса образуют цепочку, а сам запрос перемещается по этой цепочке. Каждый объект в этой цепочке при получении запроса выбирает, либо закончить обработку запроса, либо передать запрос на обработку следующему по цепочке объекту.

    * ___Когда применяется цепочка обязанностей?___
        + Когда имеется более одного объекта, который может обработать определенный запрос
        + Когда надо передать запрос на выполнение одному из нескольких объектов, точно не определяя, какому именно объекту
        + Когда набор объектов задается динамически

+ ### [Наблюдатель (observer).](https://github.com/georgedem975/patterns/tree/master/Observer)
    __Наблюдатель__ (Observer) представляет поведенческий шаблон проектирования, который использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей. И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.

    Данный паттерн еще называют Publisher-Subscriber (издатель-подписчик), поскольку отношения издателя и подписчиков характеризуют действие данного паттерна: подписчики подписываются email-рассылку определенного сайта. Сайт-издатель с помощью email-рассылки уведомляет всех подписчиков о изменениях. А подписчики получают изменения и производят определенные действия: могут зайти на сайт, могут проигнорировать уведомления и т.д.

    * ___Когда использовать паттерн Наблюдатель?___
        + Когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
        + Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
        + Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и в процессе работы программы может изменяться.

+ ### [Команда (command).](https://github.com/georgedem975/patterns/tree/master/Command)
    __Команда__ (Command) позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот объект запроса на действие и называется командой. При этом объекты, инициирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.
    Команды могут использовать параметры, которые передают ассоциированную с командой информацию. Кроме того, команды могут ставиться в очередь и также могут быть отменены.
    * ___Когда использовать команды?___
        + Когда надо передавать в качестве параметров определенные действия, вызываемые в ответ на другие действия. То есть когда необходимы функции обратного действия в ответ на определенные действия.
        + Когда необходимо обеспечить выполнение очереди запросов, а также их возможную отмену.
        + Когда надо поддерживать логгирование изменений в результате запросов. Использование логов может помочь восстановить состояние системы - для этого необходимо будет использовать последовательность запротоколированных команд.

+ ### [Состояние (state).](https://github.com/georgedem975/patterns/tree/master/State)
    __Состояние__ (State) - шаблон проектирования, который позволяет объекту изменять свое поведение в зависимости от внутреннего состояния.
    * ___Когда применяется данный паттерн?___
        + Когда поведение объекта должно зависеть от его состояния и может изменяться динамически во время выполнения
        + Когда в коде методов объекта используются многочисленные условные конструкции, выбор которых зависит от текущего состояния объекта

+ ### [Интерпретатор (interpreter).](https://github.com/georgedem975/patterns/tree/master/Interpreter)
    __Интерпретатор__ (Interpreter) определяет представление грамматики для заданного языка и интерпретатор предложений этого языка. Как правило, данный шаблон проектирования применяется для часто повторяющихся операций.

+ ### [Стратегия (strategy).](https://github.com/georgedem975/patterns/tree/master/Strategy)
    __Стратегия__ (Strategy) представляет шаблон проектирования, который определяет набор алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. В зависимости от ситуации мы можем легко заменить один используемый алгоритм другим. При этом замена алгоритма происходит независимо от объекта, который использует данный алгоритм.
    * ___Когда использовать стратегию?___
        + Когда есть несколько родственных классов, которые отличаются поведением. Можно задать один основной класс, а разные варианты поведения вынести в отдельные классы и при необходимости их применять
        + Когда необходимо обеспечить выбор из нескольких вариантов алгоритмов, которые можно легко менять в зависимости от условий
        + Когда необходимо менять поведение объектов на стадии выполнения программы
        + Когда класс, применяющий определенную функциональность, ничего не должен знать о ее реализации

+ ### [Итератор (iterator).](https://github.com/georgedem975/patterns/tree/master/Iterator)
    __Итератор__ (Iterator) предоставляет абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта без раскрытия его внутренней структуры.

+ ### [Шаблонный метод (template method).](https://github.com/georgedem975/patterns/tree/master/Template%20method)
    __Шаблонный метод__ (Template Method) определяет общий алгоритм поведения подклассов, позволяя им переопределить отдельные шаги этого алгоритма без изменения его структуры.
    * ___Когда использовать шаблонный метод?___
        + Когда планируется, что в будущем подклассы должны будут переопределять различные этапы алгоритма без изменения его структуры
        + Когда в классах, реализующим схожий алгоритм, происходит дублирование кода. Вынесение общего кода в шаблонный метод уменьшит его дублирование в подклассах.

+ ### [Посредник (mediator).](https://github.com/georgedem975/patterns/tree/master/Mediator)
    __Посредник__ (Mediator) представляет такой шаблон проектирования, который обеспечивает взаимодействие множества объектов без необходимости ссылаться друг на друга. Тем самым достигается слабосвязанность взаимодействующих объектов.
    * ___Когда используется паттерн Посредник?___
        + Когда имеется множество взаимосвязаных объектов, связи между которыми сложны и запутаны.
        + Когда необходимо повторно использовать объект, однако повторное использование затруднено в силу сильных связей с другими объектами.

+ ### [Посетитель (visitor).](https://github.com/georgedem975/patterns/tree/master/Visitor)
    __Посетитель__ (Visitor) позволяет определить операцию для объектов других классов без изменения этих классов.
    При использовании паттерна Посетитель определяются две иерархии классов: одна для элементов, для которых надо определить новую операцию, и вторая иерархия для посетителей, описывающих данную операцию.
    * ___Когда использовать данный паттерн?___
        + Когда имеется много объектов разнородных классов с разными интерфейсами, и требуется выполнить ряд операций над каждым из этих объектов
        + Когда классам необходимо добавить одинаковый набор операций без изменения этих классов
        + Когда часто добавляются новые операции к классам, при этом общая структура классов стабильна и практически не изменяется

---
## порождающие (creational).

+ ### [Абстрактная фабрика (abstract factory).](https://github.com/georgedem975/patterns/tree/master/Abstract%20factory)
    __Абстрактная фабрика__ (Abstract Factory) предоставляет интерфейс для создания семейств взаимосвязанных объектов с определенными интерфейсами без указания конкретных типов данных объектов.
    * ___Когда использовать абстрактную фабрику?___
        + Когда система не должна зависеть от способа создания и компоновки новых объектов
        + Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

+ ### [Строитель (builder).](https://github.com/georgedem975/patterns/tree/master/Builder)
    __Строитель__ (Builder) - шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.
    * ___Когда использовать паттерн Строитель?___
        + Когда процесс создания нового объекта не должен зависеть от того, из каких частей этот объект состоит и как эти части связаны между собой
        + Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

+ ### [Фабричный метод (factory method).](https://github.com/georgedem975/patterns/tree/master/Factory%20method)
    __Фабричный метод__ (Factory Method) - это паттерн, который определяет интерфейс для создания объектов некоторого класса, но непосредственное решение о том, объект какого класса создавать происходит в подклассах. То есть паттерн предполагает, что базовый класс делегирует создание объектов классам-наследникам.

    * ___Когда надо применять паттерн?___
        + Когда заранее неизвестно, объекты каких типов необходимо создавать
        + Когда система должна быть независимой от процесса создания новых объектов и расширяемой: в нее можно легко вводить новые классы, объекты которых система должна создавать.
        + Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

+ ### [Прототип (prototype).](https://github.com/georgedem975/patterns/tree/master/Prototype)
    __Прототип__ (Prototype) позволяет создавать объекты на основе уже ранее созданных объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.
    * ___Когда использовать Прототип?___
        + Когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
        + Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
        + Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

+ ### [Одиночка (singleton).]()

---
## структурные (structural).

+ ### [Адаптер (adapter).](https://github.com/georgedem975/patterns/tree/master/Adapter)
    __Адаптер__ (Adapter) предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного паттерна мы можем использовать вместе классы с несовместимыми интерфейсами.
    * ___Когда надо использовать Адаптер?___
        + Когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
        + Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

+ ### [Прокси (proxy).](https://github.com/georgedem975/patterns/tree/master/Proxy)
    __Заместитель__ (Proxy) предоставляет объект-заместитель, который управляет доступом к другому объекту. То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его.
    * ___Когда использовать прокси?___
        + Когда надо осуществлять взаимодействие по сети, а объект-проси должен имитировать поведения объекта в другом адресном пространстве. Использование прокси позволяет снизить накладные издержки при передачи данных через сеть. Подобная ситуация еще называется удалённый заместитель (remote proxies)
        + Когда нужно управлять доступом к ресурсу, создание которого требует больших затрат. Реальный объект создается только тогда, когда он действительно может понадобится, а до этого все запросы к нему обрабатывает прокси-объект. Подобная ситуация еще называется виртуальный заместитель (virtual proxies)
        + Когда необходимо разграничить доступ к вызываемому объекту в зависимости от прав вызывающего объекта. Подобная ситуация еще называется защищающий заместитель (protection proxies)
        + Когда нужно вести подсчет ссылок на объект или обеспечить потокобезопасную работу с реальным объектом. Подобная ситуация называется "умные ссылки" (smart reference)

+ ### [Мост (bridge).](https://github.com/georgedem975/patterns/tree/master/Bridge)
    __Мост__ (Bridge) - структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, и реализацию можно было изменять независимо друг от друга.
    Даже если мы отделим абстракцию от конкретных реализаций, то у нас все равно все наследуемые классы будут жестко привязаны к интерфейсу, определяемому в базовом абстрактном классе. Для преодоления жестких связей и служит паттерн Мост.
    * ___Когда использовать данный паттерн?___
        + Когда надо избежать постоянной привязки абстракции к реализации
        + Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. То есть изменения в абстракции не должно привести к изменениям в реализации

+ ### [Компоновщик (composite).](https://github.com/georgedem975/patterns/tree/master/Composite)
    __Компоновщик__ (Composite) объединяет группы объектов в древовидную структуру по принципу "часть-целое" и позволяет клиенту одинаково работать как с отдельными объектами, так и с группой объектов.
    Образно реализацию паттерна можно представить в виде меню, которое имеет различные пункты. Эти пункты могут содержать подменю, в которых, в свою очередь, также имеются пункты. То есть пункт меню служит с одной стороны частью меню, а с другой стороны еще одним меню. В итоге мы однообразно можем работать как с пунктом меню, так и со всем меню в целом.
    * ___Когда использовать компоновщик?___
        + Когда объекты должны быть реализованы в виде иерархической древовидной структуры
        + Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. То есть целое и его части должны реализовать один и тот же интерфейс

+ ### [Декоратор (decorator).](https://github.com/georgedem975/patterns/tree/master/Decorator)
    __Декоратор__ (Decorator) представляет структурный шаблон проектирования, который позволяет динамически подключать к объекту дополнительную функциональность. Для определения нового функционала в классах нередко используется наследование. Декораторы же предоставляет наследованию более гибкую альтернативу, поскольку позволяют динамически в процессе выполнения определять новые возможности у объектов.
    * ___Когда следует использовать декораторы?___
        + Когда надо динамически добавлять к объекту новые функциональные возможности. При этом данные возможности могут быть сняты с объекта.

+ ### [Фасад (facade).](https://github.com/georgedem975/patterns/tree/master/Facade)
    __Фасад__ (Facade) представляет шаблон проектирования, который позволяет скрыть сложность системы с помощью предоставления упрощенного интерфейса для взаимодействия с ней.
    * ___Когда использовать фасад?___
        + Когда имеется сложная система, и необходимо упростить с ней работу. Фасад позволит определить одну точку взаимодействия между клиентом и системой.
        + Когда надо уменьшить количество зависимостей между клиентом и сложной системой. Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
        + Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга.

+ ### [Приспособленец (flyweight).](https://github.com/georgedem975/patterns/tree/master/Flyweight)
    __Приспособленец__ (Flyweight) - структурный шаблон проектирования, который позволяет использовать разделяемые объекты сразу в нескольких контекстах. Данный паттерн используется преимущественно для оптимизации работы с памятью.
    * ___Паттерн Приспособленец следует применять при соблюдении всех следующих условий:___
        + Когда приложение использует большое количество однообразных объектов, из-за чего происходит выделение большого количества памяти
        + Когда часть состояния объекта, которая является изменяемой, можно вынести во вне. Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.