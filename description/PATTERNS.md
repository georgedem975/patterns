# Краткое описание паттернов.
---

## Немного о паттернах.

Что представляют собой паттерны проектирования? Паттерн представляет определенный способ построения программного кода для решения часто встречающихся проблем проектирования. В данном случае предполагается, что есть некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.

## Виды паттернов.
* __Порождающие паттерны__ — это паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов.
*  __Структурные паттерны__ - группа паттернов рассматривает, как классы и объекты образуют более крупные структуры - более сложные по характеру классы и объекты
* __Поведенчиские паттерны__ - они определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение

## Как выбрать нужный паттерн?

Прежде всего при решении какой-нибудь проблемы надо выделить все используемые сущности и связи между ними и абстрагировать их от конкретной ситуации. Затем надо посмотреть, вписывается ли абстрактная форма решения задачи в определенный паттерн. Например, суть решаемой задачи может состоять в создании новых объектов. В этом случае, возможно, стоит посмотреть на порождающие паттерны. Причем лучше не сразу взять какой-то определенный паттерн - первый, который показался нужным, а посмотреть на несколько родственных паттернов из одной группы, которые решают одну и ту же задачу.

---
## поведенческие (behavioral).

+ ### [Хранитель (memento).](https://github.com/georgedem975/patterns/tree/master/Memento)
    __Хранитель__ (Memento), также известный как Снимок – поведенческий паттерн проектирования. Он позволяет определять, сохранять, а также восстанавливать предыдущие состояния объектов без нарушения принципа инкапсуляции. Самый простой и наглядный пример использования этого паттерна – некий текстовый редактор, который позволяет изменять форматирование текста и других элементов. Но при этом пользователь может эти изменения отменить.

    ___Когда использовать Memento?___
    + Когда нужно сохранить состояние объекта для возможного последующего восстановления
    + Когда сохранение состояния должно проходить без нарушения принципа инкапсуляции

+ ### [Цепочка обязанностей (chain of responsibility).](https://github.com/georgedem975/patterns/tree/master/Chain%20of%20responsibility)
    __Цепочка Обязанностей__ (Chain of responsibility) - поведенческий шаблон проектирования, который позволяет избежать жесткой привязки отправителя запроса к получателю. Все возможные обработчики запроса образуют цепочку, а сам запрос перемещается по этой цепочке. Каждый объект в этой цепочке при получении запроса выбирает, либо закончить обработку запроса, либо передать запрос на обработку следующему по цепочке объекту.

    ___Когда применяется цепочка обязанностей?___
    + Когда имеется более одного объекта, который может обработать определенный запрос
    + Когда надо передать запрос на выполнение одному из нескольких объектов, точно не определяя, какому именно объекту
    + Когда набор объектов задается динамически

+ ### [Наблюдатель (observer).](https://github.com/georgedem975/patterns/tree/master/Observer)
    __Наблюдатель__ (Observer) представляет поведенческий шаблон проектирования, который использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей. И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей.

    Данный паттерн еще называют Publisher-Subscriber (издатель-подписчик), поскольку отношения издателя и подписчиков характеризуют действие данного паттерна: подписчики подписываются email-рассылку определенного сайта. Сайт-издатель с помощью email-рассылки уведомляет всех подписчиков о изменениях. А подписчики получают изменения и производят определенные действия: могут зайти на сайт, могут проигнорировать уведомления и т.д.

    ___Когда использовать паттерн Наблюдатель?___
    + Когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
    + Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
    + Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и в процессе работы программы может изменяться.

+ ### [Команда (command).](https://github.com/georgedem975/patterns/tree/master/Command)
    __Команда__ (Command) позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот объект запроса на действие и называется командой. При этом объекты, инициирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.
    Команды могут использовать параметры, которые передают ассоциированную с командой информацию. Кроме того, команды могут ставиться в очередь и также могут быть отменены.
    ___Когда использовать команды?___
    + Когда надо передавать в качестве параметров определенные действия, вызываемые в ответ на другие действия. То есть когда необходимы функции обратного действия в ответ на определенные действия.
    + Когда необходимо обеспечить выполнение очереди запросов, а также их возможную отмену.
    + Когда надо поддерживать логгирование изменений в результате запросов. Использование логов может помочь восстановить состояние системы - для этого необходимо будет использовать последовательность запротоколированных команд.

+ ### [Состояние (state).](https://github.com/georgedem975/patterns/tree/master/State)
    __Состояние__ (State) - шаблон проектирования, который позволяет объекту изменять свое поведение в зависимости от внутреннего состояния.
    ___Когда применяется данный паттерн?___
    + Когда поведение объекта должно зависеть от его состояния и может изменяться динамически во время выполнения
    + Когда в коде методов объекта используются многочисленные условные конструкции, выбор которых зависит от текущего состояния объекта

+ ### [Интерпретатор (interpreter).](https://github.com/georgedem975/patterns/tree/master/Interpreter)
    __Интерпретатор__ (Interpreter) определяет представление грамматики для заданного языка и интерпретатор предложений этого языка. Как правило, данный шаблон проектирования применяется для часто повторяющихся операций.

+ ### [Стратегия (strategy).](https://github.com/georgedem975/patterns/tree/master/Strategy)
    __Стратегия__ (Strategy) представляет шаблон проектирования, который определяет набор алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. В зависимости от ситуации мы можем легко заменить один используемый алгоритм другим. При этом замена алгоритма происходит независимо от объекта, который использует данный алгоритм.
    ___Когда использовать стратегию?___
    + Когда есть несколько родственных классов, которые отличаются поведением. Можно задать один основной класс, а разные варианты поведения вынести в отдельные классы и при необходимости их применять
    + Когда необходимо обеспечить выбор из нескольких вариантов алгоритмов, которые можно легко менять в зависимости от условий
    + Когда необходимо менять поведение объектов на стадии выполнения программы
    + Когда класс, применяющий определенную функциональность, ничего не должен знать о ее реализации

+ ### [Итератор (iterator).](https://github.com/georgedem975/patterns/tree/master/Iterator)
    __Итератор__ (Iterator) предоставляет абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта без раскрытия его внутренней структуры.

+ ### [Шаблонный метод (template method).](https://github.com/georgedem975/patterns/tree/master/Template%20method)
    __Шаблонный метод__ (Template Method) определяет общий алгоритм поведения подклассов, позволяя им переопределить отдельные шаги этого алгоритма без изменения его структуры.
    ___Когда использовать шаблонный метод?___
    + Когда планируется, что в будущем подклассы должны будут переопределять различные этапы алгоритма без изменения его структуры
    + Когда в классах, реализующим схожий алгоритм, происходит дублирование кода. Вынесение общего кода в шаблонный метод уменьшит его дублирование в подклассах.

+ ### [Посредник (mediator).](https://github.com/georgedem975/patterns/tree/master/Mediator)
    __Посредник__ (Mediator) представляет такой шаблон проектирования, который обеспечивает взаимодействие множества объектов без необходимости ссылаться друг на друга. Тем самым достигается слабосвязанность взаимодействующих объектов.
    ___Когда используется паттерн Посредник?___
    + Когда имеется множество взаимосвязаных объектов, связи между которыми сложны и запутаны.
    + Когда необходимо повторно использовать объект, однако повторное использование затруднено в силу сильных связей с другими объектами.

+ ### [Посетитель (visitor).]()

---
## порождающие (creational).

+ ### [Абстрактная фабрика (abstract factory).]()
+ ### [Строитель (builder).]()
+ ### [Фабричный метод (factory method).]()
+ ### [Прототип (prototype).]()
+ ### [Одиночка (singleton).]()

---
## структурные (structural).

+ ### [Адаптер (adapter).]()
+ ### [Прокси (proxy).]()
+ ### [Мост (bridge).]()
+ ### [Компоновщик (composite).]()
+ ### [Декоратор (decorator).]()
+ ### [Фасад (facade).]()
+ ### [Приспособленец (flyweight).]()